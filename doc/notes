================================================================================================
Things To Note
================================================================================================

CoreRecorder::recordAccess
    Sees the event record and pops it off of the "stack"
    Starts to spawn timing events and based on the type
        chooses to add children to the event or just delay
    
OOOCore::bbl
    Reads the bbl input and starts to record the information in it

OOOCore::BblFunc
    Reads in the bbl that is associated with the core (given by a tid)
    ^ Cannot find where this is called
        ^ Seems to be passed on as a function pointer

Function Pointer Data Structures
    fPtrs[ associated with a tid ]
    When bblPtr is called this is the BblFunc
    Function pointers are called in zsim.cpp from line 168
        ^ The basic block function is called in BBL_InsertCall

vDSO ? (Line 718 in zsim.cpp)

ooo_core.cpp:
	Line 48: Lists the stages used in the Westmere microarchitecture
				Fetch, Decode, Issue, Dispatch
				Issue: ???
				Dispatch: comprised of the RAT, ROB, ResStations

ooo_core.h:
	Line 419: Lists some of their vars used to profile the number of cycles for F,D,I stalls

zsim.cpp:
	Line 168: analysis functions called before instrumentation. 
	these functions eventually link to the core.h interface. 
	speculation: this is where stalls can occur? ooocore and simple core implement core.h?
	************* answer: calls are made to the analysis functions through function pointers in core.h
	simple_core.cpp, ooo_core.cpp, etc... all implement this interface and decide what to do with instruction analysis seperately. 
	simple_core.cpp is a relatively short and easy file to understand. 
	specifically, look at the load, store, and bbl methods in simple_core.cpp.
	they make calls to the FilterCache to determine the actual stalling to update the current clock cycle.
	

scheduler.h:
	schedules threads to run in a round-robin fashion. 
	if thread does not complete in allotted time, thread is paused and other threads are given a turn.
	TODO: inspect the scheduling methods in this class.

================================================================================================
Abbreviations
================================================================================================

cRec = core recorder
LSU  = load store unit
RF   = register file
IW   = instruction width (I think) (might also be instruction window)
WSZ  = ??? (line 103 in ooo_core.h)

================================================================================================
Things to Figure Out
================================================================================================

What's the difference between Issue and Dispatch
	my guess: issue to res_stations, dispatch to execution units?

Might need to look more at the WindowStructure class and its schedule() function in ooo_core.h (line 104)
	wtf is poisonRange()?

================================================================================================
Notes from meeting
================================================================================================

Things that are children to the TimingEvent

timing_event.h -> DelayEvent, Crossing_event
ddr_mem.cpp
core_recorder.cpp
weave_md1_mem.h
timing_event.h
detailed_mem.h
ooo_core_recorder.cpp

WHAT TO ASK TMRW:
1) Should the scheduler (scheduler.h) be modified from the top down? or should we be adding in timingevents?
   - the first option simulates an actual SMT on the instruction level. 
   - the second option is a pseudo-smt done in an analysis fashion after execution.
   - first may give more accurate results, second may be easier to implement.  

2) meeting with daniel sanchez.
   - figure out ZSIM structure
   - timing events related to instructions
   - how does pin fit in (just to make sure)
   - scheduling the different threads
   - ooocore work
   - figure out how to debug ZSIM 

================================================================================================
Things said with Mattan
================================================================================================

- Check how branch mispredicts are done
    - Followup for Mattan
    - Inside the pipeline so should be helpful as a starting point to look into the pipeline
	- PAg branc predictor
	  - there's a small chunk of code around ooo_core.cpp 377 that simulates a branch misprediction
	  - line 408 records the event I believe, trace it down and you get to ooo_core_recorder.cpp 216 recordAccess() 
	  - not sure what that function does ... pretty messy

- linux - address space linux? virtualization (ASLR) 
    - feature that randomizes the virtual address
    - turn off in order to see the same addresses for each prg that is called. Turn off ASLR
        - To disable:
            echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
        - To enable:
            echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
        NOTE: Requires superuser (we probably don't have)

        - Create new shell without ASLR (I haven't tested and may not work over ssh)
            setarch `uname -m` -R /bin/bash

- Double check that the scheduler is running the two different processes on different cores
    - Can we check or get the processes to run on the same core? - ^ associated with this work
    - Mattan thinks we should avoid the scheduler files. We are looking at the set below the scheduler.
    - Look at instruction cache misses for timing
- How much time to add
- Try removing L1 Cache to see what happens
    - make the miss penalty zero
    - make each of the cores share the cache and see if this affects current implementation (I think that's what he said)?
- Private L1, L2, Public L3
 
# print the proccesses as zsim executes them.
# insert this at the top of the Trace function in zsim.cpp
# vim src/zsim.cpp +699
// DEBUG: print process parent id and id (ppid, pid).
printf("(%d, %d)\n", getppid(), getpid());

Extending the Simulator
Important:
When you add a new .cpp file, make sure you notify src/SConscript.
Otherwise, you will get linking errors during compilation.


